1.  VMP的JCC运算不会出现任何jcc指令，如果运算通过改vEIP即可

2.  细节运算

    1.  通过ZF标志位的1还是0，进行跳转

    2.  乘法运算：对欲跳转的地址做一个乘法运算，例如ZF=0，(地址A，地址B)，首先ZF\*A=0,ZF=1-ZF,A\*ZF=A,B+A=A

    3.  且运算：对欲跳转的地址做一个且运算，例如ZF=1，(地址A,地址B),

        1.  rCX= NEG(1-ZF) //rCX = 0

        2.  ZF = NEG(ZF)

        3.  ZF = AND(ZF,地址A) //ZF=地址A

        4.  rCX = AND(rCX,地址B) //rCX = 0

        5.  rAX = OR(ZF,rCX) //ZF + rCX =地址A

        6.  CALL rAX //CALL地址A

        7.  首先1对标志位进行进行相减(1-ZF)，和不相减ZF标志位各保存一份！最后进行且运算与或运算得出结果

    4.  判断一个数是否为零，模拟Elfgas标志位，1-(((x)\|(-x)) \>\>
        31)，返回值与ZF位一样

    5.  VMP中把所有的加法通过数学运算变成了加法

        1.  NOT(NOT(A)+B)==A-B

            1.  NOT(A) = -A-1

            2.  NOT(-A-1+B) = A+1-B-1=A-B

        2.  通过这个运算产生的结果是相同的，但是eflags标志位另外需要判断

        3.  所以需要解决一个问题，NOT(NOT(A)+B)产生的标志位与A-B产生的标志位需要完全一样(不能光考虑ZF标志位)

        4.  所有的eflags标志位分为两类，一类是结果标志位：Z,S，一类是C，O过程标志位

            1.  VMP把eflags的实现分为两个部分，每产生一个eflags都要进行pushfd

            2.  NOT(A)+B 产生过程标志位(C,O) pushfd

            3.  NOT(NOT(A)+B) 产生结果标志位(Z,S) pushfd

            4.  对栈里的标志位进行or运算合并，最后得到一个真实的标志位

            5.  总结：在vmp可以追踪pushfd标志位和lahf(lahf在vmp当中都是作为混淆用的指令)，已知vmp通过两个部分进行产生eflags，且还有任意一部分做加减法运算都会产生eflags，比如mov
                eax,[esp+8]，当这行代码被虚拟化指令
                esp+8也会产生eflags，所以还需要pushfd进行保存

            6.  通过模拟运行搜索出产生多个pushfd，针对每一个pushfd进行二分法测试模糊测试(也叫黑盒测试)完成爆破，这种方式打印出来的pushfd比较多，如果是jcc跳转那么vm里面肯定需要取出ZF标志位，可能是shr右移6位或and
                0x40取得zf标志位

            7.  在所遇到的vmp版本，取出ZF标志位一直都是ZF和and标志位

                1.  and eax,0x40

                2.  shr eax,6

                3.  泛用性 vs
                    效率的矛盾，追求泛用性好呢还是效率好呢？泛用性最好的方式就是把全部的混淆代码去除，然后对VM的整个代码还原(越泛用工程量越大)

                    1.  使用pushfd+and+shr定位vJcc的效率比较高

                    2.  单独使用pushfd定位vJcc效率比较低

                    3.  效率高往往泛用性不好

                    4.  如果泛用性做得很好，及时下一次小幅度更新，则有可能依旧不随着更新而使分析手段改变。但是效率高的可能会因为一次小幅度的更新而使分析手段变差

                    5.  现在面临着一个问题，效率高的方法是怎么找到的，也可能是从泛用性好的方式分析出效率技术手段

                    6.  泛用性效率 目前来说是一个沉淀关系

            8.  一般都会呈现出这种形式

                1.  ![](media/3a0d5cee280b1f89f855d8f2dc211e9c.png)

                2.  这种称为黑箱测试_分支包含关系，干预43E02B的zf，如果干预了则没有运行到452d28这个指针，说明可能是一个这样的包含跳转

                3.  ![](media/086e3d9d2692ce90901e8927e272979d.png)

                    1.  这里优缺点，就是把一个jcc翻转之后可能存在循环关系，但是在调试器里面将jcc翻转之后可能存在循环关系，但是没有通过模拟进行输入查看到下一个jcc的结果，所以这里就无脑黑箱测试了！

                    2.  ![](media/3dfaa6e535ef7ef0258aa30624355bcb.png)

                4.  黑箱测试_临近调用关系：指的是预结果保持临近的指令调用关系，从而确定黑箱关系，找出爆破掉
