1.  C++的优化

    1.  C++默认的优化为

    2.  ![](media/6562dc2da414baa863427918bc6a0889.png)

    3.  如果开启了使速度最大化(O/2)，则编译的时候会把strcmp和scanf这些函数进行内联，比如main函数有一个strcmp函数，则会把strcmp内嵌到main函数，同时需要关闭启动内部函数

    4.  在做VM实验的时候，把随机基址关掉，有助于选择函数(确保函数地址不会被随机化)，需要关闭**随机基址的选项**

2.  VMProtect

    1.  VMP添加函数的方案是添加进程，添加进程这个“进程”应该是翻译过来的，正常来说应该返回成过程或例程，汇编的叫法是过程

3.  模拟器

    1.  配置模拟器调试环境

        1.  需要将代码块，数据块块dump下来存入到寄存器结构体中，数据块例如”%s”所在的内存块比如rdata段

        2.  需要把寄存器环境给存入到寄存器结构体中

        3.  需要把栈的内存块也需要dump下来存储到模拟器结构中

        4.  Dump的注意点，运行到一个点进行暂停，**然后全部dump下来**，不能说运行一段代码dump一段内存块，这种方式可能造成内存块不一样而产生不同形式的错误(dump的时间点需要一致，可以利用虚拟机的快照进行实验)

    2.  运行原理 开始计次 执行模拟指令 读内存 反汇编 过滤反汇编的指令

    3.  结构体系

        1.  Mnemonic： 就是opcode，例如”call”

        2.  Op_str： 如果opcode + op_str 等于整个指令的字符串

        3.  Size： 指令的长度，例如call Imm32 的长度为5

        4.  Address：
            当前的虚拟地址，需要自己设置，相当于BeaEngine的VirtualAddress

        5.  Detail：
            在初始化的时候，需要使用cs_option指定反汇编的深度，例如有一些反汇编只需要指令指令的字符串即可，使用cs_option(CS_OPT_DETAIL,CS_OPT_ON)，打开detail这个选项

            1.  detail.x86.op_count： 指定指令的操作数，比如call
                Imm32为1个操作数

            2.  detail.x86.operands[n]：

                1.  指定每一个操作数的有效情况，例如detail.x86.operands[1]指定第一个操作数的有效情况，每一个数组下标表示第N个操作数

                2.  Type：例如call
                    Imm32，操作数1的类型为X86_OP_IMM类型，是一个立即数类型，如果是push
                    ebp，则第一个操作数的类型为X86_OP_REG类型

                3.  Reg： 这个属性为所指定的寄存器，例如push
                    ebp，则reg属性为X86_REG_EBP，如果没有任何类型则表示为INVALID

                4.  Imm：如果是REG类型则表示后面的立即数imm失效。

                5.  Access：其中access如果为1则表示”读”REG，如果为2表示”写”REG，例如pop
                    ebp，表示把[esp]的值写入到ebp，如果为3则有读有些，比如add
                    ebp,3，即对ebp进行了读操作，又对ebp进行了加上3操作，这些多对操作数的读写，表示”显式读写”

            3.  regs_read_count：隐式读的寄存器数量，比如指令push
                ebp，在压栈的时候肯定需要读取ebp的值，push
                ebp这叫做显式读取，但是同时存在esp-4的操作的隐式读，如果这个值大于等于1，则表示有一个隐式读写

            4.  regs_read[n]：每一个下标，需要查询宏定义，例如push
                reg，这个指令对esp进行了又读又写
                先读取esp的值然后esp=esp-4，push
                reg的reg是显式读写，而esp是隐式读，对数据追踪，污染分析，局部去混淆，自动化及其有效

    4.  在模拟的过程中出现elfgas为287，dbg的eflags为395，相差一个TF位，这个是调试器做单步所需要用到的控制标志位，需要关注的标志位有
        Z,C,S,O这4个位

    5.  模拟的过程中出现API的调用，因为API不在生成的EXE的范围，是系统的一个DLL，则需要自己进行手工模拟，例如模拟scanf的行为

        1.  如果regs.regs.r_eip==API scanf函数地址(case)

        2.  将返回的缓存区buf指向的值改成一个错误的文本就行

        3.  Eip = vmEnter返回地址

        4.  Esp = esp += 8 两个参数

        5.  ![](media/19851ab39187bf4b7f40b7378677f82f.png)

    6.  如果模拟出现的寄存器和调试器的寄存器不相等。例如ecx，函数调用的过程中这个函数调用约定eax，ecx，edx这三个寄存器在32位汇编中为**易变寄存器**，如果模拟了一个API，调试器是进入API内部了，而模拟器仅仅是你模拟API了，然后出来发现调试器的ecx和模拟器的ecx不一样极为正常，所以需要将调试器出来的时候这种易变寄存器的变化再次从模拟器写入到环境即可(根据需要)

4.  反调试

    1.  Windowsx64系统中，分为x32和x64，如果在x64层做反调试，在x32层感觉不到，这时候可以用在32位系统上，即x64层的反调试失效，但是如果在64层挂钩，x32层的反调试失效
