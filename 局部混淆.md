1.  VMP

    1.  VMP的基本混淆基本上对于最后一个寄存器为写例如mov eax,edx mov
        eax,ecx此时这两句是混淆指令

    2.  VMP没有对立即数进行AND和AOT运算，如果进行AND运算可能还原不出第三个操作数

    3.  CLC
        清除C标志位，在VMP中一般为无效指令，因为后面的shl，adc都会影响C标志位

    4.  在WinHex中Ctrl+B可以覆盖数据

    5.  Bswap 高2字节与低2字节互换，mov edi,0Xf2ed82d20X82d2f2ed

    6.  Stc 将CF进位标志位置1

    7.  去混淆

        1.  指令的功能在于写

        2.  对同一个位置的连续两次写，第一次写是无效的

    8.  简化约定

        1.  对内存的写指令是有效的

            1.  对于VMP是有效的的，但对于TMD这类是加壳软件无效

        2.  操作栈的指令是有效的

    9.  一些细节

        1.  寄存器地址细分

        2.  Lea指令不访问内存

        3.  [mem]操作数中有对base和indx的隐式读

            1.  所以需要对每一个位进行细分，例如Z C O
                S，但是反汇编引擎并没有这个强大的功能

        4.  Eflags的读写是否需要继续细分

        5.  具有确定结构的算数指令是否认为是读写

    10. Cmp reg,reg
        对eflags标志位进行隐式的读写，btr指令也具有读写(置C位)，bt具有只读属性(置C位)例如bt
        eax,1
        判断eax的第一位是否是1如果是1则把CF位置1，mov指令在x86汇编下不改变eflags3

    11. 表格去混淆

        1.  首先把一个寄存器分成 eax_h ah
            al，一列一列分析，有没有相邻的两个w，如果有把第一个w去掉，如果只剩下r了，再把r去掉

        2.  Eflags不是完全的写操作，因为当一个指令要改变eflags的时候，只对eflags确定的一个位进行写，所以会先读后写
