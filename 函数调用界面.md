1.  TMD

    1.  TMD的壳包括多个虚拟机，可供自己选择，默认第一个为最复杂的虚拟机

    2.  TMD的虚拟机检测勾上即不检查，否则检测

    3.  TMD最强的虚拟机混淆默认都是基于堆栈的混淆

    4.  TMD在调试器运行的过程中可能会出现in
        edx,dx这类的混淆。这个指令的输入指令r3没有权限去执行，所以这一句是混淆指令，默认执行之后造造成异常TMD断点的SEH即可代为处理，里面处理的机制是当前EIP+1，跳过这一句异常

2.  函数调用界面总结

    1.  当断入一个函数，其返回地址在vmp的区段处，然后在代码段下一个断点，然后直接可以运行到下一个函数的调用入口(push
        ebp)

    2.  其意思是
        vm区段代码执行完成真正的代码段入口(界面处的状态是真实的可以得到参数)执行

    3.  利用调用函数界面进行爆破一个程序

3.  定位函数调用界面的意义

    1.  流程结构化

    2.  界面处的状态是真实的(不是虚拟机)

4.  VMP

    1.  VMP一个函数进入虚拟机首先先做push imm32 call
        imm32，所以可以动态追踪这个call
        imm32，来判断是否进入下一个call(这表明一个函数的调用)，到达之后其实是函数返回的状态栈状态

    2.  VMP函数调用界面，A函数与B函数都进行了虚拟化，但是A函数结束的时候并没有退出虚拟机而是直接将参数转移转入到了B函数的虚拟机(虚拟机参数转移一般抓不到)，这是VMP的虚拟机的函数隐匿性现象(函数隐匿与变异逃逸差不多)

    3.  但是每一个函数头部都会跳转到虚拟机入口，如果能保证每一个函数正常调用到指定的函数头即可不必生成函数头跳转入虚拟机，假设窗口回调函数可能会被kernel进行调用、C语言有函数指针的方式，所以保证安全性所以还是必须给函数头部加入一个虚拟机入口(虚拟机合流)

    4.  调用特征

        1.  PE区段区域跳转(可能标志着一个函数的调用，VMP里这种情况不多)

            1.  VMP可能会对区段间的跳转做一个混淆，故意价入混淆，使无法判断是否是函数入口，有一部分虚拟机代码故意塞入代码段(虚拟机漂移)

        2.  VM出入口特征，比如call 在早期的VM版本，是push xxx jmp xxxx

        3.  特殊寄存器

            1.  抓住真实的ebp值，比如一个真实的入口函数，其函数返回处ebp的值是一样的，然后ebp会交给其他虚拟机进行使用，所以他到下一次函数调用ebp的值肯定也是一样的，再根据代码块的终点完成虚拟机特征分析！

            2.  在vmp中，因为存在**虚拟机参数**转移的情况，所以不会有进入虚拟机这一个步骤，如果要追踪EBP的话，那么追踪到的可能就是下一个函数过程的返回处

5.  软件保护

    1.  传入参数为加密之后的参数 比较以加密之后的参数进行比较，不能出现铭文

    2.  返回值不能简单,比如返回0x1231,0x45789
